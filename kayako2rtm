#!/usr/bin/env python2

#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

"""Synchronize assigned tickets from Kayako 4.x to RTM

Utilizes raw SQL queries rather than Kayako's API since the API is broken in the
Kayako version used at the company I work at currently.

Yes this is ugly procedural code. The intention was to write-once-and-forget since
Kayako will only be used for another year there, tops :)
"""

# Setup logging before importing any other modules to ensure they don't configure logging before we do
# This also means we need to run through the configparser setup
import logging
import ConfigParser
import sys
if __name__ == '__main__':
	if len(sys.argv) != 2 or sys.argv[1] in ("-h", "--help"):
		print "Usage: kayako2rtm <configfile>"
		sys.exit(1)
	config = ConfigParser.ConfigParser()
	fh = open(sys.argv[1], 'r')
	config.readfp(fh)
	logging.basicConfig(level=getattr(logging, config.get("Logging", "level").upper(), None))
else:
	logging.basicConfig()

import MySQLdb, MySQLdb.cursors
import rtm
import re
from time import sleep
from datetime import datetime

ticketregex = re.compile("[!#]?([A-Z]{3}-[0-9]{3}-[0-9]{5})")
replaceregex = re.compile("[^a-zA-Z0-9_]")

if __name__ == '__main__':
	if len(sys.argv) != 2 or sys.argv[1] in ("-h", "--help"):
		print "Usage: kayako2rtm <configfile>"
		sys.exit(1)
	config = ConfigParser.ConfigParser()
	fh = open(sys.argv[1], 'r')
	config.readfp(fh)

	logging.info("Connecting to MySQL server")
	kayakodb = MySQLdb.connect(host=config.get("Kayako", "host"), port=config.getint("Kayako", "port"), user=config.get("Kayako", "user"), passwd=config.get("Kayako", "passwd"), db=config.get("Kayako", "db"), cursorclass=MySQLdb.cursors.DictCursor)
	cursor = kayakodb.cursor()
	logging.info("Getting an RTM API object")
	milk = rtm.createRTM(config.get("RTM", "key"), config.get("RTM", "secret"), config.get("RTM", "token"))
	logging.info("Getting an RTM timeline object")
	timeline = milk.timelines.create().timeline
	logging.info("Fetching list of assigned tickets from database")
	cursor.execute("""
	               SELECT ticketid, ownerstaffid, duetime, t.ticketstatusid, markasresolved, ticketmaskid, subject, s.title
	               FROM swtickets as t
	               INNER JOIN swticketstatus as s
	               ON t.ticketstatusid = s.ticketstatusid
	               WHERE ownerstaffid = %s;""",
	               (config.get("Kayako", "staffid"),))
	tickets = {}
	logging.debug("Query result:")
	for row in cursor.fetchall():
		logging.debug(repr(row))
		tickets[ row['ticketmaskid'] ] = row

	seen = {} # {ticketid: completed, ticketid, completed, ... }
	tasklist = milk.tasks.getList(filter="tag:{0}".format(config.get("RTM", "maintag")))
	if hasattr(tasklist.tasks, "list") and hasattr(tasklist.tasks.list, "__getitem__"):
		#if tasklist.tasks.list is not None:
		for taskseries in tasklist.tasks.list:
			# Workaround for taskseries.taskseries not being iterable when only 1 task was returned
			if not hasattr(taskseries.taskseries, "__iter__"):
				taskseries.taskseries = [taskseries.taskseries]
			for task in taskseries.taskseries:
				r = ticketregex.search(task.name)
				if r is None:
					logging.warning('No regex match found while parsing task "{0}"'.format(task.name))
				else:
					ticketid = r.groups()[0]

					if not task.task.completed:
						# Ensure ticket is still assigned
						if ticketid not in tickets:
							logging.info('Ticket "{0}" not in currently assigned tickets, completing it'.format(ticketid))
							milk.tasks.complete(timeline=timeline, list_id=config.getint("RTM", "listid"), taskseries_id=task.id, task_id=task.task.id)
							seen[ticketid] = True
						else:
							# Update tags if needed
							status = tickets[ticketid]['title'].lower().replace(' ', '_')
							status = replaceregex.sub('', status)
							tags = [config.get("RTM", "maintag"), status] + config.get("RTM", "extratags").split(",")
							if sorted(task.tags.tag) == sorted(tags):
								logging.info('Tags for ticket {0} up to date'.format(ticketid))
							else:
								logging.info('Tags for ticket {0} out of date, updating'.format(ticketid))
								milk.tasks.setTags(timeline=timeline, list_id=config.getint("RTM", "listid"), taskseries_id=task.id, task_id=task.task.id, tags=tags)
							# Check if resolved
							if tickets[ticketid]['markasresolved']:
								logging.info('Ticket "{0}" has a resolved status type, completing'.format(ticketid))
								milk.tasks.complete(timeline=timeline, list_id=config.getint("RTM", "listid"), taskseries_id=task.id, task_id=task.task.id)
								seen[ticketid] = True
							else:
								# Compare due times
								due = None if tickets[ticketid]['duetime'] == 0 else datetime.fromtimestamp(tickets[ticketid]['duetime']).isoformat()
								# RTM places a 'Z' behind the time string, which .isoformat() doesn't
								if not due:
									if task.task.due:
										logging.info('Ticket {0} has no due time, removing duetime from task'.format(ticketid))
										milk.tasks.setDueDate(timeline=timeline, list_id=config.getint("RTM", "listid"), taskseries_id=task.id, task_id=task.task.id)
									else:
										logging.info('Due time for ticket {0} unchanged, no duetime on ticket and task'.format(ticketid))
								else:
									if task.task.due[-1] == "Z": due += "Z"
									if task.task.due != due:
										logging.info('Due time for ticket {0} changed, updating'.format(ticketid))
										milk.tasks.setDueDate(timeline=timeline, list_id=config.getint("RTM", "listid"), taskseries_id=task.id, task_id=task.task.id, due=due, has_due_time="1")
									else:
										logging.info('Due time for ticket {0} unchanged'.format(ticketid))
								seen[ticketid] = False
					else:
						seen[ticketid] = True
	else:
		logging.info("No current tasks found with tag:{0}".format(config.get("RTM", "maintag")))
	logging.debug('Seen contains: {0}'.format(repr(seen)))

	for id, ticket in tickets.iteritems():
		# The or (...) handles cases where a ticket has been reopened
		if id not in seen or (seen[id] == True and ticket['markasresolved'] == False):
			logging.info('Ticket {0} not seen or reopened, adding'.format(id))
			# Add using parse=0 to ensure the subject isn't parsed
			name = "[{0}] {1}".format(ticket['ticketmaskid'], ticket['subject'])
			try:
				task = milk.tasks.add(timeline=timeline, list_id=config.getint("RTM", "listid"), name=name, parse=0)
			except UnicodeDecodeError:
				# pyrtm uses urllib.quote which doesn't handle non-ascii characters
				task = milk.tasks.add(timeline=timeline, list_id=config.getint("RTM", "listid"), name=name.decode('utf-8', 'ignore').encode('ascii', 'ignore'), parse=0)
				logging.warning('Non-ASCII characters removed from task name')
			# Then add the tags and what-not with separate calls (There is no API method in RTM's API to do this right away with the .add() method)
			status = ticket['title'].lower().replace(' ', '_')
			status = replaceregex.sub('', status)
			tags = [config.get("RTM", "maintag"), status] + config.get("RTM", "extratags").split(",")
			url = config.get("Kayako", "directurl") + str(ticket['ticketid'])
			milk.tasks.setTags(timeline=timeline, list_id=config.getint("RTM", "listid"), taskseries_id=task.list.taskseries.id, task_id=task.list.taskseries.task.id, tags=tags)
			milk.tasks.setURL(timeline=timeline, list_id=config.getint("RTM", "listid"), taskseries_id=task.list.taskseries.id, task_id=task.list.taskseries.task.id, url=url)
			if ticket['duetime'] > 0:
				duestr = datetime.fromtimestamp(ticket['duetime']).isoformat()
				logging.info('Ticket {0} set due at {1}'.format(id, duestr))
				milk.tasks.setDueDate(timeline=timeline, list_id=config.getint("RTM", "listid"), taskseries_id=task.list.taskseries.id, task_id=task.list.taskseries.task.id, due=duestr, has_due_time="1")
			if ticket['markasresolved']:
				logging.info('Ticket {0} has a resolved status type, completing'.format(id))
				milk.tasks.complete(timeline=timeline, list_id=config.getint("RTM", "listid"), taskseries_id=task.list.taskseries.id, task_id=task.list.taskseries.task.id)
			sleep(5)
		else:
			logging.info('Ticket {0} already in RTM, skipping'.format(id))


